{"ast":null,"code":"/**!\n* tippy.js v5.2.1\n* (c) 2017-2020 atomiks\n* MIT License\n*/\nimport { e as errorWhen, _ as _extends, d as defaultProps, t as tippy, a as div, r as removeProperties, n as normalizeToArray, i as includes, s as setVisibilityState, w as warnWhen, B as BACKDROP_CLASS, g as getOwnerDocument, b as isMouseEvent, u as useIfDefined, c as currentInput, f as closestCallback, h as getBasePlacement, j as arrayFrom } from './tippy.chunk.esm.js';\nexport { l as createTippyWithPlugins, t as default, k as hideAll, R as roundArrow } from './tippy.chunk.esm.js';\nimport 'popper.js';\n/**\n * Re-uses a single tippy element for many different tippy instances.\n * Replaces v4's `tippy.group()`.\n */\n\nvar createSingleton = function createSingleton(tippyInstances, optionalProps,\n/** @deprecated use Props.plugins */\nplugins) {\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  if (plugins === void 0) {\n    plugins = [];\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of tippy', 'instances. The passed value was', String(tippyInstances)].join(' '));\n  }\n\n  plugins = optionalProps.plugins || plugins;\n  tippyInstances.forEach(function (instance) {\n    instance.disable();\n  });\n\n  var userAria = _extends({}, defaultProps, {}, optionalProps).aria;\n\n  var currentAria;\n  var currentTarget;\n  var shouldSkipUpdate = false;\n  var references = tippyInstances.map(function (instance) {\n    return instance.reference;\n  });\n  var singleton = {\n    fn: function fn(instance) {\n      function handleAriaDescribedByAttribute(isShow) {\n        if (!currentAria) {\n          return;\n        }\n\n        var attr = \"aria-\" + currentAria;\n\n        if (isShow && !instance.props.interactive) {\n          currentTarget.setAttribute(attr, instance.popperChildren.tooltip.id);\n        } else {\n          currentTarget.removeAttribute(attr);\n        }\n      }\n\n      return {\n        onAfterUpdate: function onAfterUpdate(_, _ref) {\n          var aria = _ref.aria; // Ensure `aria` for the singleton instance stays `null`, while\n          // changing the `userAria` value\n\n          if (aria !== undefined && aria !== userAria) {\n            if (!shouldSkipUpdate) {\n              userAria = aria;\n            } else {\n              shouldSkipUpdate = true;\n              instance.setProps({\n                aria: null\n              });\n              shouldSkipUpdate = false;\n            }\n          }\n        },\n        onDestroy: function onDestroy() {\n          tippyInstances.forEach(function (instance) {\n            instance.enable();\n          });\n        },\n        onMount: function onMount() {\n          handleAriaDescribedByAttribute(true);\n        },\n        onUntrigger: function onUntrigger() {\n          handleAriaDescribedByAttribute(false);\n        },\n        onTrigger: function onTrigger(_, event) {\n          var target = event.currentTarget;\n          var index = references.indexOf(target); // bail-out\n\n          if (target === currentTarget) {\n            return;\n          }\n\n          currentTarget = target;\n          currentAria = userAria;\n\n          if (instance.state.isVisible) {\n            handleAriaDescribedByAttribute(true);\n          }\n\n          instance.popperInstance.reference = target;\n          instance.setContent(tippyInstances[index].props.content);\n        }\n      };\n    }\n  };\n  return tippy(div(), _extends({}, optionalProps, {\n    plugins: [singleton].concat(plugins),\n    aria: null,\n    triggerTarget: references\n  }));\n};\n\nvar BUBBLING_EVENTS_MAP = {\n  mouseover: 'mouseenter',\n  focusin: 'focus',\n  click: 'click'\n};\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */\n\nfunction delegate(targets, props,\n/** @deprecated use Props.plugins */\nplugins) {\n  if (plugins === void 0) {\n    plugins = [];\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));\n  }\n\n  plugins = props.plugins || plugins;\n  var listeners = [];\n  var childTippyInstances = [];\n  var target = props.target;\n  var nativeProps = removeProperties(props, ['target']);\n\n  var parentProps = _extends({}, nativeProps, {\n    plugins: plugins,\n    trigger: 'manual'\n  });\n\n  var childProps = _extends({}, nativeProps, {\n    plugins: plugins,\n    showOnCreate: true\n  });\n\n  var returnValue = tippy(targets, parentProps);\n  var normalizedReturnValue = normalizeToArray(returnValue);\n\n  function onTrigger(event) {\n    if (!event.target) {\n      return;\n    }\n\n    var targetNode = event.target.closest(target);\n\n    if (!targetNode) {\n      return;\n    } // Get relevant trigger with fallbacks:\n    // 1. Check `data-tippy-trigger` attribute on target node\n    // 2. Fallback to `trigger` passed to `delegate()`\n    // 3. Fallback to `defaultProps.trigger`\n\n\n    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // Only create the instance if the bubbling event matches the trigger type\n\n    if (!includes(trigger, BUBBLING_EVENTS_MAP[event.type])) {\n      return;\n    }\n\n    var instance = tippy(targetNode, childProps);\n\n    if (instance) {\n      childTippyInstances = childTippyInstances.concat(instance);\n    }\n  }\n\n  function on(node, eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    node.addEventListener(eventType, handler, options);\n    listeners.push({\n      node: node,\n      eventType: eventType,\n      handler: handler,\n      options: options\n    });\n  }\n\n  function addEventListeners(instance) {\n    var reference = instance.reference;\n    on(reference, 'mouseover', onTrigger);\n    on(reference, 'focusin', onTrigger);\n    on(reference, 'click', onTrigger);\n  }\n\n  function removeEventListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function applyMutations(instance) {\n    var originalDestroy = instance.destroy;\n\n    instance.destroy = function (shouldDestroyChildInstances) {\n      if (shouldDestroyChildInstances === void 0) {\n        shouldDestroyChildInstances = true;\n      }\n\n      if (shouldDestroyChildInstances) {\n        childTippyInstances.forEach(function (instance) {\n          instance.destroy();\n        });\n      }\n\n      childTippyInstances = [];\n      removeEventListeners();\n      originalDestroy();\n    };\n\n    addEventListeners(instance);\n  }\n\n  normalizedReturnValue.forEach(applyMutations);\n  return returnValue;\n}\n\nvar animateFill = {\n  name: 'animateFill',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var _instance$popperChild = instance.popperChildren,\n        tooltip = _instance$popperChild.tooltip,\n        content = _instance$popperChild.content;\n    var backdrop = instance.props.animateFill ? createBackdropElement() : null;\n\n    function addBackdropToPopperChildren() {\n      instance.popperChildren.backdrop = backdrop;\n    }\n\n    return {\n      onCreate: function onCreate() {\n        if (backdrop) {\n          addBackdropToPopperChildren();\n          tooltip.insertBefore(backdrop, tooltip.firstElementChild);\n          tooltip.setAttribute('data-animatefill', '');\n          tooltip.style.overflow = 'hidden';\n          instance.setProps({\n            animation: 'shift-away',\n            arrow: false\n          });\n        }\n      },\n      onMount: function onMount() {\n        if (backdrop) {\n          var transitionDuration = tooltip.style.transitionDuration;\n          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the\n          // tooltip element. `clip-path` is the other alternative but is not\n          // well-supported and is buggy on some devices.\n\n          content.style.transitionDelay = Math.round(duration / 10) + \"ms\";\n          backdrop.style.transitionDuration = transitionDuration;\n          setVisibilityState([backdrop], 'visible'); // Warn if the stylesheets are not loaded\n\n          if (process.env.NODE_ENV !== \"production\") {\n            warnWhen(getComputedStyle(backdrop).position !== 'absolute', \"The `tippy.js/dist/backdrop.css` stylesheet has not been\\n              imported!\\n              \\n              The `animateFill` plugin requires this stylesheet to work.\");\n            warnWhen(getComputedStyle(tooltip).transform === 'none', \"The `tippy.js/animations/shift-away.css` stylesheet has not\\n              been imported!\\n              \\n              The `animateFill` plugin requires this stylesheet to work.\");\n          }\n        }\n      },\n      onShow: function onShow() {\n        if (backdrop) {\n          backdrop.style.transitionDuration = '0ms';\n        }\n      },\n      onHide: function onHide() {\n        if (backdrop) {\n          setVisibilityState([backdrop], 'hidden');\n        }\n      },\n      onAfterUpdate: function onAfterUpdate() {\n        // With this type of prop, it's highly unlikely it will be changed\n        // dynamically. We'll leave out the diff/update logic it to save bytes.\n        // `popperChildren` is assigned a new object onAfterUpdate\n        addBackdropToPopperChildren();\n      }\n    };\n  }\n};\n\nfunction createBackdropElement() {\n  var backdrop = div();\n  backdrop.className = BACKDROP_CLASS;\n  setVisibilityState([backdrop], 'hidden');\n  return backdrop;\n}\n\nvar followCursor = {\n  name: 'followCursor',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference,\n        popper = instance.popper;\n    var originalReference = null; // Support iframe contexts\n    // Static check that assumes any of the `triggerTarget` or `reference`\n    // nodes will never change documents, even when they are updated\n\n    var doc = getOwnerDocument(instance.props.triggerTarget || reference); // Internal state\n\n    var lastMouseMoveEvent;\n    var mouseCoords = null;\n    var isInternallySettingControlledProp = false; // These are controlled by this plugin, so we need to store the user's\n    // original prop value\n\n    var userProps = instance.props;\n\n    function setUserProps(props) {\n      var keys = Object.keys(props);\n      keys.forEach(function (prop) {\n        userProps[prop] = useIfDefined(props[prop], userProps[prop]);\n      });\n    }\n\n    function getIsManual() {\n      return instance.props.trigger.trim() === 'manual';\n    }\n\n    function getIsEnabled() {\n      // #597\n      var isValidMouseEvent = getIsManual() ? true : // Check if a keyboard \"click\"\n      mouseCoords !== null && !(mouseCoords.clientX === 0 && mouseCoords.clientY === 0);\n      return instance.props.followCursor && isValidMouseEvent;\n    }\n\n    function getIsInitialBehavior() {\n      return currentInput.isTouch || instance.props.followCursor === 'initial' && instance.state.isVisible;\n    }\n\n    function resetReference() {\n      if (instance.popperInstance && originalReference) {\n        instance.popperInstance.reference = originalReference;\n      }\n    }\n\n    function handlePlacement() {\n      // Due to `getVirtualOffsets()`, we need to reverse the placement if it's\n      // shifted (start -> end, and vice-versa)\n      // Early bail-out\n      if (!getIsEnabled() && instance.props.placement === userProps.placement) {\n        return;\n      }\n\n      var placement = userProps.placement;\n      var shift = placement.split('-')[1];\n      isInternallySettingControlledProp = true;\n      instance.setProps({\n        placement: getIsEnabled() && shift ? placement.replace(shift, shift === 'start' ? 'end' : 'start') : placement\n      });\n      isInternallySettingControlledProp = false;\n    }\n\n    function handlePopperListeners() {\n      if (!instance.popperInstance) {\n        return;\n      } // Popper's scroll listeners make sense for `true` only. TODO: work out\n      // how to only listen horizontal scroll for \"horizontal\" and vertical\n      // scroll for \"vertical\"\n\n\n      if (getIsEnabled() && getIsInitialBehavior()) {\n        instance.popperInstance.disableEventListeners();\n      }\n    }\n\n    function handleMouseMoveListener() {\n      if (getIsEnabled()) {\n        addListener();\n      } else {\n        resetReference();\n      }\n    }\n\n    function triggerLastMouseMove() {\n      if (getIsEnabled()) {\n        onMouseMove(lastMouseMoveEvent);\n      }\n    }\n\n    function addListener() {\n      doc.addEventListener('mousemove', onMouseMove);\n    }\n\n    function removeListener() {\n      doc.removeEventListener('mousemove', onMouseMove);\n    }\n\n    function onMouseMove(event) {\n      var _lastMouseMoveEvent = lastMouseMoveEvent = event,\n          clientX = _lastMouseMoveEvent.clientX,\n          clientY = _lastMouseMoveEvent.clientY;\n\n      if (!instance.popperInstance || !instance.state.currentPlacement) {\n        return;\n      } // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n\n\n      var isCursorOverReference = closestCallback(event.target, function (el) {\n        return el === reference;\n      });\n      var followCursor = instance.props.followCursor;\n      var isHorizontal = followCursor === 'horizontal';\n      var isVertical = followCursor === 'vertical';\n      var isVerticalPlacement = includes(['top', 'bottom'], getBasePlacement(instance.state.currentPlacement)); // The virtual reference needs some size to prevent itself from overflowing\n\n      var _getVirtualOffsets = getVirtualOffsets(popper, isVerticalPlacement),\n          size = _getVirtualOffsets.size,\n          x = _getVirtualOffsets.x,\n          y = _getVirtualOffsets.y;\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        // Preserve custom position ReferenceObjects, which may not be the\n        // original targets reference passed as an argument\n        if (originalReference === null) {\n          originalReference = instance.popperInstance.reference;\n        }\n\n        instance.popperInstance.reference = {\n          referenceNode: reference,\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect: function getBoundingClientRect() {\n            var rect = reference.getBoundingClientRect();\n            return {\n              width: isVerticalPlacement ? size : 0,\n              height: isVerticalPlacement ? 0 : size,\n              top: (isHorizontal ? rect.top : clientY) - y,\n              bottom: (isHorizontal ? rect.bottom : clientY) + y,\n              left: (isVertical ? rect.left : clientX) - x,\n              right: (isVertical ? rect.right : clientX) + x\n            };\n          }\n        };\n        instance.popperInstance.update();\n      }\n\n      if (getIsInitialBehavior()) {\n        removeListener();\n      }\n    }\n\n    return {\n      onAfterUpdate: function onAfterUpdate(_, partialProps) {\n        if (!isInternallySettingControlledProp) {\n          setUserProps(partialProps);\n\n          if (partialProps.placement) {\n            handlePlacement();\n          }\n        } // A new placement causes the popperInstance to be recreated\n\n\n        if (partialProps.placement) {\n          handlePopperListeners();\n        } // Wait for `.update()` to set `instance.state.currentPlacement` to\n        // the new placement\n\n\n        requestAnimationFrame(triggerLastMouseMove);\n      },\n      onMount: function onMount() {\n        triggerLastMouseMove();\n        handlePopperListeners();\n      },\n      onShow: function onShow() {\n        if (getIsManual()) {\n          // Since there's no trigger event to use, we have to use these as\n          // baseline coords\n          mouseCoords = {\n            clientX: 0,\n            clientY: 0\n          }; // Ensure `lastMouseMoveEvent` doesn't access any other properties\n          // of a MouseEvent here\n\n          lastMouseMoveEvent = mouseCoords;\n          handlePlacement();\n          handleMouseMoveListener();\n        }\n      },\n      onTrigger: function onTrigger(_, event) {\n        // Tapping on touch devices can trigger `mouseenter` then `focus`\n        if (mouseCoords) {\n          return;\n        }\n\n        if (isMouseEvent(event)) {\n          mouseCoords = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n          lastMouseMoveEvent = event;\n        }\n\n        handlePlacement();\n        handleMouseMoveListener();\n      },\n      onUntrigger: function onUntrigger() {\n        // If untriggered before showing (`onHidden` will never be invoked)\n        if (!instance.state.isVisible) {\n          removeListener();\n          mouseCoords = null;\n        }\n      },\n      onHidden: function onHidden() {\n        removeListener();\n        resetReference();\n        mouseCoords = null;\n      }\n    };\n  }\n};\n\nfunction getVirtualOffsets(popper, isVerticalPlacement) {\n  var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;\n  return {\n    size: size,\n    x: isVerticalPlacement ? size : 0,\n    y: isVerticalPlacement ? 0 : size\n  };\n} // position. This will require the `followCursor` plugin's fixes for overflow\n// due to using event.clientX/Y values. (normalizedPlacement, getVirtualOffsets)\n\n\nvar inlinePositioning = {\n  name: 'inlinePositioning',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n\n    function getIsEnabled() {\n      return !!instance.props.inlinePositioning;\n    }\n\n    return {\n      onHidden: function onHidden() {\n        if (getIsEnabled()) {\n          instance.popperInstance.reference = reference;\n        }\n      },\n      onShow: function onShow() {\n        if (!getIsEnabled()) {\n          return;\n        }\n\n        instance.popperInstance.reference = {\n          referenceNode: reference,\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect: function getBoundingClientRect() {\n            return getInlineBoundingClientRect(instance.state.currentPlacement && getBasePlacement(instance.state.currentPlacement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()));\n          }\n        };\n      }\n    };\n  }\n};\n\nfunction getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects) {\n  // Not an inline element, or placement is not yet known\n  if (clientRects.length < 2 || currentBasePlacement === null) {\n    return boundingRect;\n  }\n\n  switch (currentBasePlacement) {\n    case 'top':\n    case 'bottom':\n      {\n        var firstRect = clientRects[0];\n        var lastRect = clientRects[clientRects.length - 1];\n        var isTop = currentBasePlacement === 'top';\n        var top = firstRect.top;\n        var bottom = lastRect.bottom;\n        var left = isTop ? firstRect.left : lastRect.left;\n        var right = isTop ? firstRect.right : lastRect.right;\n        var width = right - left;\n        var height = bottom - top;\n        return {\n          top: top,\n          bottom: bottom,\n          left: left,\n          right: right,\n          width: width,\n          height: height\n        };\n      }\n\n    case 'left':\n    case 'right':\n      {\n        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {\n          return rects.left;\n        }));\n        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {\n          return rects.right;\n        }));\n        var measureRects = clientRects.filter(function (rect) {\n          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;\n        });\n        var _top = measureRects[0].top;\n        var _bottom = measureRects[measureRects.length - 1].bottom;\n        var _left = minLeft;\n        var _right = maxRight;\n\n        var _width = _right - _left;\n\n        var _height = _bottom - _top;\n\n        return {\n          top: _top,\n          bottom: _bottom,\n          left: _left,\n          right: _right,\n          width: _width,\n          height: _height\n        };\n      }\n\n    default:\n      {\n        return boundingRect;\n      }\n  }\n}\n\nvar sticky = {\n  name: 'sticky',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference,\n        popper = instance.popper;\n\n    function getReference() {\n      return instance.popperInstance ? instance.popperInstance.reference : reference;\n    }\n\n    function shouldCheck(value) {\n      return instance.props.sticky === true || instance.props.sticky === value;\n    }\n\n    var prevRefRect = null;\n    var prevPopRect = null;\n\n    function updatePosition() {\n      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;\n      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;\n\n      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {\n        instance.popperInstance.update();\n      }\n\n      prevRefRect = currentRefRect;\n      prevPopRect = currentPopRect;\n\n      if (instance.state.isMounted) {\n        requestAnimationFrame(updatePosition);\n      }\n    }\n\n    return {\n      onMount: function onMount() {\n        if (instance.props.sticky) {\n          updatePosition();\n        }\n      }\n    };\n  }\n};\n\nfunction areRectsDifferent(rectA, rectB) {\n  if (rectA && rectB) {\n    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;\n  }\n\n  return true;\n}\n\nexport { animateFill, createSingleton, delegate, followCursor, inlinePositioning, sticky };","map":{"version":3,"sources":["../src/addons/createSingleton.ts","../src/addons/delegate.ts","../src/plugins/animateFill.ts","../src/plugins/followCursor.ts","../src/plugins/inlinePositioning.ts","../src/plugins/sticky.ts"],"names":["createSingleton","optionalProps","plugins","errorWhen","Array","String","tippyInstances","instance","userAria","shouldSkipUpdate","references","singleton","fn","attr","isShow","currentTarget","onAfterUpdate","aria","onDestroy","onMount","handleAriaDescribedByAttribute","onUntrigger","onTrigger","target","event","index","currentAria","tippy","div","triggerTarget","BUBBLING_EVENTS_MAP","mouseover","focusin","click","props","listeners","childTippyInstances","nativeProps","removeProperties","parentProps","trigger","childProps","showOnCreate","returnValue","normalizedReturnValue","normalizeToArray","targetNode","defaultProps","includes","options","node","eventType","handler","reference","on","originalDestroy","shouldDestroyChildInstances","removeEventListeners","addEventListeners","animateFill","name","defaultValue","tooltip","content","backdrop","createBackdropElement","onCreate","addBackdropToPopperChildren","animation","arrow","transitionDuration","duration","Number","Math","setVisibilityState","warnWhen","getComputedStyle","onShow","onHide","followCursor","popper","originalReference","doc","getOwnerDocument","mouseCoords","isInternallySettingControlledProp","userProps","keys","Object","useIfDefined","isValidMouseEvent","getIsManual","currentInput","getIsEnabled","placement","shift","getIsInitialBehavior","addListener","resetReference","onMouseMove","clientX","clientY","lastMouseMoveEvent","isCursorOverReference","closestCallback","el","isHorizontal","isVertical","isVerticalPlacement","getBasePlacement","size","x","y","getVirtualOffsets","referenceNode","clientWidth","clientHeight","getBoundingClientRect","rect","width","height","top","bottom","left","right","removeListener","setUserProps","partialProps","handlePlacement","handlePopperListeners","requestAnimationFrame","triggerLastMouseMove","handleMouseMoveListener","isMouseEvent","onHidden","inlinePositioning","getInlineBoundingClientRect","arrayFrom","clientRects","currentBasePlacement","firstRect","lastRect","isTop","minLeft","rects","maxRight","measureRects","sticky","prevRefRect","prevPopRect","currentRefRect","shouldCheck","getReference","currentPopRect","areRectsDifferent","updatePosition","rectA","rectB"],"mappings":";;;;;;;;AAMA;;;;;AAIA,IAAMA,eAAgC,GAAG,SAAnCA,eAAmC,CAAA,cAAA,EAAA,aAAA;;AAAA,OAAA,EAKpC;MAHHC,aAGG,KAAA,KAAA,C,EAAA;AAHHA,IAAAA,aAGG,GAHa,EAAhBA;;;MAEAC,OACG,KAAA,KAAA,C,EAAA;AADHA,IAAAA,OACG,GADO,EAAVA;;;6CAEa;AACXC,IAAAA,SAAS,CACP,CAACC,KAAK,CAALA,OAAAA,CADM,cACNA,CADM,EAEP,CAAA,0EAAA,EAAA,iCAAA,EAGEC,MAAM,CAHR,cAGQ,CAHR,EAAA,IAAA,CAFFF,GAEE,CAFO,CAATA;;;AAUFD,EAAAA,OAAO,GAAGD,aAAa,CAAbA,OAAAA,IAAVC,OAAAA;AAEAI,EAAAA,cAAc,CAAdA,OAAAA,CAAuB,UAAA,QAAA,EAAY;AACjCC,IAAAA,QAAQ,CAARA,OAAAA;AADFD,GAAAA;;MAIIE,QAAQ,GAAG,QAAA,CAAA,EAAA,EAAA,YAAA,EAAA,EAAA,EAAA,aAAA,CAAA,CAAf,I;;MACA,W;MACA,a;MACIC,gBAAgB,GAApB,K;MAEMC,UAAU,GAAG,cAAc,CAAd,GAAA,CAAmB,UAAA,QAAA,EAAQ;WAAIH,QAAQ,CAAZ,S;AAA9C,GAAmB,C;MAEbI,SAAiB,GAAG;AACxBC,IAAAA,EADwB,EAAA,SAAA,EAAA,CAAA,QAAA,EACX;eACX,8B,CAAA,M,EAA+D;YACzD,CAAJ,W,EAAkB;;;;YAIZC,IAAI,GAAA,UAAV,W;;YAEIC,MAAM,IAAI,CAACP,QAAQ,CAARA,KAAAA,CAAf,W,EAA2C;AACzCQ,UAAAA,aAAa,CAAbA,YAAAA,CAAAA,IAAAA,EAAiCR,QAAQ,CAARA,cAAAA,CAAAA,OAAAA,CAAjCQ,EAAAA;AADF,S,MAEO;AACLA,UAAAA,aAAa,CAAbA,eAAAA,CAAAA,IAAAA;;;;aAIG;AACLC,QAAAA,aADK,EAAA,SAAA,aAAA,CAAA,CAAA,EAAA,IAAA,EAC0B;cAAbC,IAAa,GAAA,IAAA,CAAbA,I,CAAa,C;;;cAGzBA,IAAI,KAAJA,SAAAA,IAAsBA,IAAI,KAA9B,Q,EAA6C;gBACvC,CAAJ,gB,EAAuB;AACrBT,cAAAA,QAAQ,GAARA,IAAAA;AADF,a,MAEO;AACLC,cAAAA,gBAAgB,GAAhBA,IAAAA;AACAF,cAAAA,QAAQ,CAARA,QAAAA,CAAkB;AAACU,gBAAAA,IAAI,EAAE;AAAP,eAAlBV;AACAE,cAAAA,gBAAgB,GAAhBA,KAAAA;;;AAVD,SAAA;AAcLS,QAAAA,SAdK,EAAA,SAAA,SAAA,GAca;AAChBZ,UAAAA,cAAc,CAAdA,OAAAA,CAAuB,UAAA,QAAA,EAAY;AACjCC,YAAAA,QAAQ,CAARA,MAAAA;AADFD,WAAAA;AAfG,SAAA;AAmBLa,QAAAA,OAnBK,EAAA,SAAA,OAAA,GAmBW;AACdC,UAAAA,8BAA8B,CAA9BA,IAA8B,CAA9BA;AApBG,SAAA;AAsBLC,QAAAA,WAtBK,EAAA,SAAA,WAAA,GAsBe;AAClBD,UAAAA,8BAA8B,CAA9BA,KAA8B,CAA9BA;AAvBG,SAAA;AAyBLE,QAAAA,SAzBK,EAAA,SAAA,SAAA,CAAA,CAAA,EAAA,KAAA,EAyBqB;cAClBC,MAAM,GAAGC,KAAK,CAApB,a;cACMC,KAAK,GAAGf,UAAU,CAAVA,OAAAA,CAFU,MAEVA,C,CAFU,CAAA;;cAKpBa,MAAM,KAAV,a,EAA8B;;;;AAI9BR,UAAAA,aAAa,GAAbA,MAAAA;AACAW,UAAAA,WAAW,GAAXA,QAAAA;;cAEInB,QAAQ,CAARA,KAAAA,CAAJ,S,EAA8B;AAC5Ba,YAAAA,8BAA8B,CAA9BA,IAA8B,CAA9BA;;;AAGFb,UAAAA,QAAQ,CAARA,cAAAA,CAAAA,SAAAA,GAAAA,MAAAA;AAEAA,UAAAA,QAAQ,CAARA,UAAAA,CAAoBD,cAAc,CAAdA,KAAc,CAAdA,CAAAA,KAAAA,CAApBC,OAAAA;;AA3CG,O;;AAhBe,G;SAiEnBoB,KAAK,CAACC,GAAD,EAAA,EAAA,QAAA,CAAA,EAAA,EAAA,aAAA,EAAA;AAEV1B,IAAAA,OAAO,EAAA,CAAA,SAAA,EAAA,MAAA,CAFG,OAEH,CAFG;AAGVe,IAAAA,IAAI,EAHM,IAAA;AAIVY,IAAAA,aAAa,EAAEnB;AAJL,GAAA,CAAA,C;AA/Fd,CAAA;;ACHA,IAAMoB,mBAAmB,GAAG;AAC1BC,EAAAA,SAAS,EADiB,YAAA;AAE1BC,EAAAA,OAAO,EAFmB,OAAA;AAG1BC,EAAAA,KAAK,EAAE;AAHmB,CAA5B;;;;;;AAUA,SAAA,QAAA,CAAA,OAAA,EAAA,KAAA;;AAAA,OAAA,EAKyB;MADvB/B,OACuB,KAAA,KAAA,C,EAAA;AADvBA,IAAAA,OACuB,GADH,EAApBA;;;6CAEa;AACXC,IAAAA,SAAS,CACP,EAAE+B,KAAK,IAAIA,KAAK,CADT,MACP,CADO,EAEP,CAAA,4EAAA,EAAA,kDAAA,EAAA,IAAA,CAFF/B,GAEE,CAFO,CAATA;;;AASFD,EAAAA,OAAO,GAAGgC,KAAK,CAALA,OAAAA,IAAVhC,OAAAA;MAEIiC,SAA2B,GAA/B,E;MACIC,mBAA+B,GAAnC,E;MAEOb,MAhBgB,GAgBNW,KAhBM,CAAA,M;MAkBjBG,WAAW,GAAGC,gBAAgB,CAAA,KAAA,EAAQ,CAA5C,QAA4C,CAAR,C;;MAC9BC,WAAW,GAAA,QAAA,CAAA,EAAA,EAAA,WAAA,EAAA;AAAoBrC,IAAAA,OAAO,EAA3B,OAAA;AAA6BsC,IAAAA,OAAO,EAAE;AAAtC,GAAA,C;;MACXC,UAAU,GAAA,QAAA,CAAA,EAAA,EAAA,WAAA,EAAA;AAAoBvC,IAAAA,OAAO,EAA3B,OAAA;AAA6BwC,IAAAA,YAAY,EAAE;AAA3C,GAAA,C;;MAEVC,WAAW,GAAGhB,KAAK,CAAA,OAAA,EAAzB,WAAyB,C;MACnBiB,qBAAqB,GAAGC,gBAAgB,CAA9C,WAA8C,C;;WAE9C,S,CAAA,K,EAAuC;QACjC,CAACrB,KAAK,CAAV,M,EAAmB;;;;QAIbsB,UAAU,GAAItB,KAAK,CAAN,MAACA,CAAD,OAACA,CAApB,MAAoBA,C;;QAEhB,CAAJ,U,EAAiB;;AAPoB,KAAA,CAAA;;;;;;QAe/BgB,OAAO,GACXM,UAAU,CAAVA,YAAAA,CAAAA,oBAAAA,KACAZ,KAAK,CADLY,OAAAA,IAEAC,YAAY,CAlBuB,O,CAAA,CAAA;;QAqBjC,CAACC,QAAQ,CAAA,OAAA,EAAWlB,mBAAD,CAA6BN,KAAK,CAAzD,IAAuB,CAAV,C,EAAqD;;;;QAI5DjB,QAAQ,GAAGoB,KAAK,CAAA,UAAA,EAAtB,UAAsB,C;;QAEtB,Q,EAAc;AACZS,MAAAA,mBAAmB,GAAGA,mBAAmB,CAAnBA,MAAAA,CAAtBA,QAAsBA,CAAtBA;;;;WAIJ,E,CAAA,I,EAAA,S,EAAA,O,EAAA,O,EAKQ;QADNa,OACM,KAAA,KAAA,C,EAAA;AADNA,MAAAA,OACM,GADsB,KAA5BA;;;AAEAC,IAAAA,IAAI,CAAJA,gBAAAA,CAAAA,SAAAA,EAAAA,OAAAA,EAAAA,OAAAA;AACAf,IAAAA,SAAS,CAATA,IAAAA,CAAe;AAACe,MAAAA,IAAI,EAAL,IAAA;AAAOC,MAAAA,SAAS,EAAhB,SAAA;AAAkBC,MAAAA,OAAO,EAAzB,OAAA;AAA2BH,MAAAA,OAAO,EAAPA;AAA3B,KAAfd;;;WAGF,iB,CAAA,Q,EAAqD;QAC5CkB,SAD4C,GAC/B9C,QAD+B,CAAA,S;AAGnD+C,IAAAA,EAAE,CAAA,SAAA,EAAA,WAAA,EAAFA,SAAE,CAAFA;AACAA,IAAAA,EAAE,CAAA,SAAA,EAAA,SAAA,EAAFA,SAAE,CAAFA;AACAA,IAAAA,EAAE,CAAA,SAAA,EAAA,OAAA,EAAFA,SAAE,CAAFA;;;WAGF,oB,GAAsC;AACpCnB,IAAAA,SAAS,CAATA,OAAAA,CAAkB,UAAA,IAAA,EAAyD;UAAvDe,IAAuD,GAAA,IAAA,CAAvDA,I;UAAMC,SAAiD,GAAA,IAAA,CAAjDA,S;UAAWC,OAAsC,GAAA,IAAA,CAAtCA,O;UAASH,OAA6B,GAAA,IAAA,CAA7BA,O;AAC5CC,MAAAA,IAAI,CAAJA,mBAAAA,CAAAA,SAAAA,EAAAA,OAAAA,EAAAA,OAAAA;AADFf,KAAAA;AAGAA,IAAAA,SAAS,GAATA,EAAAA;;;WAGF,c,CAAA,Q,EAAkD;QAC1CoB,eAAe,GAAGhD,QAAQ,CAAhC,O;;AACAA,IAAAA,QAAQ,CAARA,OAAAA,GAAmB,UAAA,2BAAA,EAA8C;UAA7CiD,2BAA6C,KAAA,KAAA,C,EAAA;AAA7CA,QAAAA,2BAA6C,GAAf,IAA9BA;;;UAClB,2B,EAAiC;AAC/BpB,QAAAA,mBAAmB,CAAnBA,OAAAA,CAA4B,UAAA,QAAA,EAAY;AACtC7B,UAAAA,QAAQ,CAARA,OAAAA;AADF6B,SAAAA;;;AAKFA,MAAAA,mBAAmB,GAAnBA,EAAAA;AAEAqB,MAAAA,oBAAoB;AACpBF,MAAAA,eAAe;AAVjBhD,KAAAA;;AAaAmD,IAAAA,iBAAiB,CAAjBA,QAAiB,CAAjBA;;;AAGFd,EAAAA,qBAAqB,CAArBA,OAAAA,CAAAA,cAAAA;SAEA,W;;;ACvHF,IAAMe,WAAwB,GAAG;AAC/BC,EAAAA,IAAI,EAD2B,aAAA;AAE/BC,EAAAA,YAAY,EAFmB,KAAA;AAG/BjD,EAAAA,EAH+B,EAAA,SAAA,EAAA,CAAA,QAAA,EAGlB;gCACgBL,QAAQ,CADxB,c;QACJuD,OADI,GAAA,qBAAA,CAAA,O;QACKC,OADL,GAAA,qBAAA,CAAA,O;QAGLC,QAAQ,GAAGzD,QAAQ,CAARA,KAAAA,CAAAA,WAAAA,GACb0D,qBADa1D,EAAAA,GAAjB,I;;aAIA,2B,GAA6C;AAC3CA,MAAAA,QAAQ,CAARA,cAAAA,CAAAA,QAAAA,GAAAA,QAAAA;;;WAGK;AACL2D,MAAAA,QADK,EAAA,SAAA,QAAA,GACY;YACf,Q,EAAc;AACZC,UAAAA,2BAA2B;AAE3BL,UAAAA,OAAO,CAAPA,YAAAA,CAAAA,QAAAA,EAA+BA,OAAO,CAAtCA,iBAAAA;AACAA,UAAAA,OAAO,CAAPA,YAAAA,CAAAA,kBAAAA,EAAAA,EAAAA;AACAA,UAAAA,OAAO,CAAPA,KAAAA,CAAAA,QAAAA,GAAAA,QAAAA;AAEAvD,UAAAA,QAAQ,CAARA,QAAAA,CAAkB;AAAC6D,YAAAA,SAAS,EAAV,YAAA;AAA0BC,YAAAA,KAAK,EAAE;AAAjC,WAAlB9D;;AATC,OAAA;AAYLY,MAAAA,OAZK,EAAA,SAAA,OAAA,GAYW;YACd,Q,EAAc;cACLmD,kBADK,GACiBR,OAAO,CADxB,KACiBA,CADjB,kB;cAENS,QAAQ,GAAGC,MAAM,CAACF,kBAAkB,CAAlBA,OAAAA,CAAAA,IAAAA,EAFZ,EAEYA,CAAD,C,CAFX,CAAA;;;;AAOZP,UAAAA,OAAO,CAAPA,KAAAA,CAAAA,eAAAA,GAAmCU,IAAI,CAAJA,KAAAA,CAAWF,QAAQ,GAAtDR,EAAmCU,IAAnCV,IAAAA;AAEAC,UAAAA,QAAQ,CAARA,KAAAA,CAAAA,kBAAAA,GAAAA,kBAAAA;AACAU,UAAAA,kBAAkB,CAAC,CAAD,QAAC,CAAD,EAVN,SAUM,CAAlBA,CAVY,CAAA;;qDAaC;AACXC,YAAAA,QAAQ,CACNC,gBAAgB,CAAhBA,QAAgB,CAAhBA,CAAAA,QAAAA,KADM,UAAA,EAARD,6KAAQ,CAARA;AAQAA,YAAAA,QAAQ,CACNC,gBAAgB,CAAhBA,OAAgB,CAAhBA,CAAAA,SAAAA,KADM,MAAA,EAARD,qLAAQ,CAARA;;;AAnCD,OAAA;AA6CLE,MAAAA,MA7CK,EAAA,SAAA,MAAA,GA6CU;YACb,Q,EAAc;AACZb,UAAAA,QAAQ,CAARA,KAAAA,CAAAA,kBAAAA,GAAAA,KAAAA;;AA/CC,OAAA;AAkDLc,MAAAA,MAlDK,EAAA,SAAA,MAAA,GAkDU;YACb,Q,EAAc;AACZJ,UAAAA,kBAAkB,CAAC,CAAD,QAAC,CAAD,EAAlBA,QAAkB,CAAlBA;;AApDC,OAAA;AAuDL1D,MAAAA,aAvDK,EAAA,SAAA,aAAA,GAuDiB;;;;AAKpBmD,QAAAA,2BAA2B;;AA5DxB,K;;AAdsB,CAAjC;;AAkFA,SAAA,qBAAA,GAAiD;MACzCH,QAAQ,GAAGpC,GAAjB,E;AACAoC,EAAAA,QAAQ,CAARA,SAAAA,GAAAA,cAAAA;AACAU,EAAAA,kBAAkB,CAAC,CAAD,QAAC,CAAD,EAAlBA,QAAkB,CAAlBA;SACA,Q;;;ACzEF,IAAMK,YAA0B,GAAG;AACjCnB,EAAAA,IAAI,EAD6B,cAAA;AAEjCC,EAAAA,YAAY,EAFqB,KAAA;AAGjCjD,EAAAA,EAHiC,EAAA,SAAA,EAAA,CAAA,QAAA,EAGpB;QACJyC,SADI,GACiB9C,QADjB,CAAA,S;QACOyE,MADP,GACiBzE,QADjB,CAAA,M;QAGP0E,iBAGI,GANG,I,CAAA,CAAA;;;;QAWLC,GAAG,GAAGC,gBAAgB,CAAC5E,QAAQ,CAARA,KAAAA,CAAAA,aAAAA,IAXlB,SAWiB,C,CAXjB,CAAA;;QAcX,kB;QACI6E,WAAsD,GAA1D,I;QACIC,iCAAiC,GAhB1B,K,CAAA,CAAA;;;QAoBLC,SAAS,GAAG/E,QAAQ,CAA1B,K;;aAEA,Y,CAAA,K,EAAmD;UAC3CgF,IAAI,GAAGC,MAAM,CAANA,IAAAA,CAAb,KAAaA,C;AACbD,MAAAA,IAAI,CAAJA,OAAAA,CAAa,UAAA,IAAA,EAAQ;AAClBD,QAAAA,SAAD,CAAA,IAAA,CAACA,GAA0BG,YAAY,CAACvD,KAAK,CAAN,IAAM,CAAN,EAAcoD,SAAS,CAA9D,IAA8D,CAAvB,CAAtCA;AADHC,OAAAA;;;aAKF,W,GAAgC;aACvBhF,QAAQ,CAARA,KAAAA,CAAAA,OAAAA,CAAAA,IAAAA,OAAP,Q;;;aAGF,Y,GAAiC;;UAEzBmF,iBAAiB,GAAGC,WAAW,KAAA,IAAA,GAAA;AAGjCP,MAAAA,WAAW,KAAXA,IAAAA,IACA,EAAEA,WAAW,CAAXA,OAAAA,KAAAA,CAAAA,IAA6BA,WAAW,CAAXA,OAAAA,KAJnC,CAII,C;aAEG7E,QAAQ,CAARA,KAAAA,CAAAA,YAAAA,IAAP,iB;;;aAGF,oB,GAAyC;aAErCqF,YAAY,CAAZA,OAAAA,IACCrF,QAAQ,CAARA,KAAAA,CAAAA,YAAAA,KAAAA,SAAAA,IAA6CA,QAAQ,CAARA,KAAAA,CAFhD,S;;;aAMF,c,GAAgC;UAC1BA,QAAQ,CAARA,cAAAA,IAAJ,iB,EAAkD;AAChDA,QAAAA,QAAQ,CAARA,cAAAA,CAAAA,SAAAA,GAAAA,iBAAAA;;;;aAIJ,e,GAAiC;;;;UAK3B,CAACsF,YAAD,EAAA,IAAmBtF,QAAQ,CAARA,KAAAA,CAAAA,SAAAA,KAA6B+E,SAAS,CAA7D,S,EAAyE;;;;UAIlEQ,SATwB,GASXR,SATW,CAAA,S;UAUzBS,KAAK,GAAGD,SAAS,CAATA,KAAAA,CAAAA,GAAAA,EAAd,CAAcA,C;AAEdT,MAAAA,iCAAiC,GAAjCA,IAAAA;AAEA9E,MAAAA,QAAQ,CAARA,QAAAA,CAAkB;AAChBuF,QAAAA,SAAS,EAAGD,YAAY,MAAZA,KAAAA,GACRC,SAAS,CAATA,OAAAA,CAAAA,KAAAA,EAAyBC,KAAK,KAALA,OAAAA,GAAAA,KAAAA,GADjBF,OACRC,CADQD,GAERC;AAHY,OAAlBvF;AAMA8E,MAAAA,iCAAiC,GAAjCA,KAAAA;;;aAGF,qB,GAAuC;UACjC,CAAC9E,QAAQ,CAAb,c,EAA8B;;AADO,OAAA,CAAA;;;;;UAQjCsF,YAAY,MAAMG,oBAAtB,E,EAA8C;AAC5CzF,QAAAA,QAAQ,CAARA,cAAAA,CAAAA,qBAAAA;;;;aAIJ,uB,GAAyC;UACnCsF,YAAJ,E,EAAoB;AAClBI,QAAAA,WAAW;AADb,O,MAEO;AACLC,QAAAA,cAAc;;;;aAIlB,oB,GAAsC;UAChCL,YAAJ,E,EAAoB;AAClBM,QAAAA,WAAW,CAAXA,kBAAW,CAAXA;;;;aAIJ,W,GAA6B;AAC3BjB,MAAAA,GAAG,CAAHA,gBAAAA,CAAAA,WAAAA,EAAAA,WAAAA;;;aAGF,c,GAAgC;AAC9BA,MAAAA,GAAG,CAAHA,mBAAAA,CAAAA,WAAAA,EAAAA,WAAAA;;;aAGF,W,CAAA,K,EAA8C;gCAChBoB,kBAAkB,GADF,K;UACrCF,OADqC,GAAA,mBAAA,CAAA,O;UAC5BC,OAD4B,GAAA,mBAAA,CAAA,O;;UAGxC,CAAC9F,QAAQ,CAAT,cAAA,IAA4B,CAACA,QAAQ,CAARA,KAAAA,CAAjC,gB,EAAkE;;AAHtB,OAAA,CAAA;;;;UAStCgG,qBAAqB,GAAGC,eAAe,CAC3ChF,KAAK,CADsC,MAAA,EAE3C,UAAA,EAAA,EAAA;eAAiBiF,EAAE,KAAnB,S;AAFF,OAA6C,C;UAKtC1B,YAdqC,GAcrBxE,QAAQ,CAda,KAcrBA,CAdqB,Y;UAetCmG,YAAY,GAAG3B,YAAY,KAAjC,Y;UACM4B,UAAU,GAAG5B,YAAY,KAA/B,U;UACM6B,mBAAmB,GAAG5D,QAAQ,CAClC,CAAA,KAAA,EADkC,QAClC,CADkC,EAElC6D,gBAAgB,CAACtG,QAAQ,CAARA,KAAAA,CAnByB,gBAmB1B,CAFkB,C,CAjBQ,CAAA;;+BAuBvB0G,iBAAiB,CAAA,MAAA,EAvBM,mBAuBN,C;UAA/BH,IAvBqC,GAAA,kBAAA,CAAA,I;UAuB/BC,CAvB+B,GAAA,kBAAA,CAAA,C;UAuB5BC,CAvB4B,GAAA,kBAAA,CAAA,C;;UAyBxCT,qBAAqB,IAAI,CAAChG,QAAQ,CAARA,KAAAA,CAA9B,W,EAA0D;;;YAGpD0E,iBAAiB,KAArB,I,EAAgC;AAC9BA,UAAAA,iBAAiB,GAAG1E,QAAQ,CAARA,cAAAA,CAApB0E,SAAAA;;;AAGF1E,QAAAA,QAAQ,CAARA,cAAAA,CAAAA,SAAAA,GAAoC;AAClC2G,UAAAA,aAAa,EADqB,SAAA;;AAGlCC,UAAAA,WAAW,EAHuB,CAAA;AAIlCC,UAAAA,YAAY,EAJsB,CAAA;AAKlCC,UAAAA,qBALkC,EAAA,SAAA,qBAAA,GAKY;gBACtCC,IAAI,GAAGjE,SAAS,CAAtB,qBAAaA,E;mBACN;AACLkE,cAAAA,KAAK,EAAEX,mBAAmB,GAAA,IAAA,GADrB,CAAA;AAELY,cAAAA,MAAM,EAAEZ,mBAAmB,GAAA,CAAA,GAFtB,IAAA;AAGLa,cAAAA,GAAG,EAAE,CAACf,YAAY,GAAGY,IAAI,CAAP,GAAA,GAAb,OAAA,IAHA,CAAA;AAILI,cAAAA,MAAM,EAAE,CAAChB,YAAY,GAAGY,IAAI,CAAP,MAAA,GAAb,OAAA,IAJH,CAAA;AAKLK,cAAAA,IAAI,EAAE,CAAChB,UAAU,GAAGW,IAAI,CAAP,IAAA,GAAX,OAAA,IALD,CAAA;AAMLM,cAAAA,KAAK,EAAE,CAACjB,UAAU,GAAGW,IAAI,CAAP,KAAA,GAAX,OAAA,IAAsCP;AANxC,a;;AAPyB,SAApCxG;AAkBAA,QAAAA,QAAQ,CAARA,cAAAA,CAAAA,MAAAA;;;UAGEyF,oBAAJ,E,EAA4B;AAC1B6B,QAAAA,cAAc;;;;WAIX;AACL7G,MAAAA,aADK,EAAA,SAAA,aAAA,CAAA,CAAA,EAAA,YAAA,EACgC;YAC/B,CAAJ,iC,EAAwC;AACtC8G,UAAAA,YAAY,CAAZA,YAAY,CAAZA;;cAEIC,YAAY,CAAhB,S,EAA4B;AAC1BC,YAAAA,eAAe;;AALgB,SAAA,CAAA;;;YAU/BD,YAAY,CAAhB,S,EAA4B;AAC1BE,UAAAA,qBAAqB;AAXY,SAAA,CAAA;;;;AAgBnCC,QAAAA,qBAAqB,CAArBA,oBAAqB,CAArBA;AAjBG,OAAA;AAmBL/G,MAAAA,OAnBK,EAAA,SAAA,OAAA,GAmBW;AACdgH,QAAAA,oBAAoB;AACpBF,QAAAA,qBAAqB;AArBlB,OAAA;AAuBLpD,MAAAA,MAvBK,EAAA,SAAA,MAAA,GAuBU;YACTc,WAAJ,E,EAAmB;;;AAGjBP,UAAAA,WAAW,GAAG;AAACgB,YAAAA,OAAO,EAAR,CAAA;AAAaC,YAAAA,OAAO,EAAE;AAAtB,WAAdjB,CAHiB,CAAA;;;AAMjBkB,UAAAA,kBAAkB,GAAlBA,WAAAA;AAEA0B,UAAAA,eAAe;AACfI,UAAAA,uBAAuB;;AAjCtB,OAAA;AAoCL9G,MAAAA,SApCK,EAAA,SAAA,SAAA,CAAA,CAAA,EAAA,KAAA,EAoCqB;;YAExB,W,EAAiB;;;;YAIb+G,YAAY,CAAhB,KAAgB,C,EAAS;AACvBjD,UAAAA,WAAW,GAAG;AAACgB,YAAAA,OAAO,EAAE5E,KAAK,CAAf,OAAA;AAAyB6E,YAAAA,OAAO,EAAE7E,KAAK,CAAC6E;AAAxC,WAAdjB;AACAkB,UAAAA,kBAAkB,GAAlBA,KAAAA;;;AAGF0B,QAAAA,eAAe;AACfI,QAAAA,uBAAuB;AAhDpB,OAAA;AAkDL/G,MAAAA,WAlDK,EAAA,SAAA,WAAA,GAkDe;;YAEd,CAACd,QAAQ,CAARA,KAAAA,CAAL,S,EAA+B;AAC7BsH,UAAAA,cAAc;AACdzC,UAAAA,WAAW,GAAXA,IAAAA;;AAtDC,OAAA;AAyDLkD,MAAAA,QAzDK,EAAA,SAAA,QAAA,GAyDY;AACfT,QAAAA,cAAc;AACd3B,QAAAA,cAAc;AACdd,QAAAA,WAAW,GAAXA,IAAAA;;AA5DG,K;;AAhLwB,CAAnC;;AAoPO,SAAA,iBAAA,CAAA,MAAA,EAAA,mBAAA,EAOL;MACM0B,IAAI,GAAGF,mBAAmB,GAAG5B,MAAM,CAAT,WAAA,GAAwBA,MAAM,CAA9D,Y;SAEO;AACL8B,IAAAA,IAAI,EADC,IAAA;AAELC,IAAAA,CAAC,EAAEH,mBAAmB,GAAA,IAAA,GAFjB,CAAA;AAGLI,IAAAA,CAAC,EAAEJ,mBAAmB,GAAA,CAAA,GAAOE;AAHxB,G;EC3QT;;;;AAEA,IAAMyB,iBAAoC,GAAG;AAC3C3E,EAAAA,IAAI,EADuC,mBAAA;AAE3CC,EAAAA,YAAY,EAF+B,KAAA;AAG3CjD,EAAAA,EAH2C,EAAA,SAAA,EAAA,CAAA,QAAA,EAG9B;QACJyC,SADI,GACS9C,QADT,CAAA,S;;aAGX,Y,GAAiC;aACxB,CAAC,CAACA,QAAQ,CAARA,KAAAA,CAAT,iB;;;WAGK;AACL+H,MAAAA,QADK,EAAA,SAAA,QAAA,GACY;YACXzC,YAAJ,E,EAAoB;AAClBtF,UAAAA,QAAQ,CAARA,cAAAA,CAAAA,SAAAA,GAAAA,SAAAA;;AAHC,OAAA;AAMLsE,MAAAA,MANK,EAAA,SAAA,MAAA,GAMU;YACT,CAACgB,YAAL,E,EAAqB;;;;AAIrBtF,QAAAA,QAAQ,CAARA,cAAAA,CAAAA,SAAAA,GAAqC;AACnC2G,UAAAA,aAAa,EADsB,SAAA;;AAGnCC,UAAAA,WAAW,EAHwB,CAAA;AAInCC,UAAAA,YAAY,EAJuB,CAAA;AAKnCC,UAAAA,qBALmC,EAAA,SAAA,qBAAA,GAKW;mBACrCmB,2BAA2B,CAChCjI,QAAQ,CAARA,KAAAA,CAAAA,gBAAAA,IACEsG,gBAAgB,CAACtG,QAAQ,CAARA,KAAAA,CAFa,gBAEd,CAFc,EAGhC8C,SAAS,CAHuB,qBAGhCA,EAHgC,EAIhCoF,SAAS,CAACpF,SAAS,CAJrB,cAIYA,EAAD,CAJuB,C;;AAND,SAArC9C;;AAXG,K;;AAVkC,CAA7C;;AA0CO,SAAA,2BAAA,CAAA,oBAAA,EAAA,YAAA,EAAA,WAAA,EAIO;;MAERmI,WAAW,CAAXA,MAAAA,GAAAA,CAAAA,IAA0BC,oBAAoB,KAAlD,I,EAA6D;WAC3D,Y;;;UAGF,oB;SACE,K;SACA,Q;;YACQC,SAAS,GAAGF,WAAW,CAA7B,CAA6B,C;YACvBG,QAAQ,GAAGH,WAAW,CAACA,WAAW,CAAXA,MAAAA,GAA7B,CAA4B,C;YACtBI,KAAK,GAAGH,oBAAoB,KAAlC,K;YAEMlB,GAAG,GAAGmB,SAAS,CAArB,G;YACMlB,MAAM,GAAGmB,QAAQ,CAAvB,M;YACMlB,IAAI,GAAGmB,KAAK,GAAGF,SAAS,CAAZ,IAAA,GAAoBC,QAAQ,CAA9C,I;YACMjB,KAAK,GAAGkB,KAAK,GAAGF,SAAS,CAAZ,KAAA,GAAqBC,QAAQ,CAAhD,K;YACMtB,KAAK,GAAGK,KAAK,GAAnB,I;YACMJ,MAAM,GAAGE,MAAM,GAArB,G;eAEO;AAACD,UAAAA,GAAG,EAAJ,GAAA;AAAMC,UAAAA,MAAM,EAAZ,MAAA;AAAcC,UAAAA,IAAI,EAAlB,IAAA;AAAoBC,UAAAA,KAAK,EAAzB,KAAA;AAA2BL,UAAAA,KAAK,EAAhC,KAAA;AAAkCC,UAAAA,MAAM,EAANA;AAAlC,S;;;SAET,M;SACA,O;;YACQuB,OAAO,GAAGtE,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAY,WAAW,CAAX,GAAA,CAAgB,UAAA,KAAA,EAAK;iBAAIuE,KAAK,CAAT,I;AAAjD,SAA4B,CAAZvE,C;YACVwE,QAAQ,GAAGxE,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAY,WAAW,CAAX,GAAA,CAAgB,UAAA,KAAA,EAAK;iBAAIuE,KAAK,CAAT,K;AAAlD,SAA6B,CAAZvE,C;YACXyE,YAAY,GAAG,WAAW,CAAX,MAAA,CAAmB,UAAA,IAAA,EAAI;iBAC1CP,oBAAoB,KAApBA,MAAAA,GACIrB,IAAI,CAAJA,IAAAA,KADJqB,OAAAA,GAEIrB,IAAI,CAAJA,KAAAA,KAHsC,Q;AAA5C,SAAqB,C;YAMfG,IAAG,GAAGyB,YAAY,CAAZA,CAAY,CAAZA,CAAZ,G;YACMxB,OAAM,GAAGwB,YAAY,CAACA,YAAY,CAAZA,MAAAA,GAAbA,CAAY,CAAZA,CAAf,M;YACMvB,KAAI,GAAV,O;YACMC,MAAK,GAAX,Q;;YACML,MAAK,GAAGK,MAAK,GAAnB,K;;YACMJ,OAAM,GAAGE,OAAM,GAArB,I;;eAEO;AAACD,UAAAA,GAAG,EAAJ,IAAA;AAAMC,UAAAA,MAAM,EAAZ,OAAA;AAAcC,UAAAA,IAAI,EAAlB,KAAA;AAAoBC,UAAAA,KAAK,EAAzB,MAAA;AAA2BL,UAAAA,KAAK,EAAhC,MAAA;AAAkCC,UAAAA,MAAM,EAANA;AAAlC,S;;;;;eAGP,Y;;;;;AC5FN,IAAM2B,MAAc,GAAG;AACrBvF,EAAAA,IAAI,EADiB,QAAA;AAErBC,EAAAA,YAAY,EAFS,KAAA;AAGrBjD,EAAAA,EAHqB,EAAA,SAAA,EAAA,CAAA,QAAA,EAGR;QACJyC,SADI,GACiB9C,QADjB,CAAA,S;QACOyE,MADP,GACiBzE,QADjB,CAAA,M;;aAGX,Y,GAAmE;aAC1DA,QAAQ,CAARA,cAAAA,GACHA,QAAQ,CAARA,cAAAA,CADGA,SAAAA,GAAP,S;;;aAKF,W,CAAA,K,EAA6D;aACpDA,QAAQ,CAARA,KAAAA,CAAAA,MAAAA,KAAAA,IAAAA,IAAkCA,QAAQ,CAARA,KAAAA,CAAAA,MAAAA,KAAzC,K;;;QAGE6I,WAA8B,GAAlC,I;QACIC,WAA8B,GAAlC,I;;aAEA,c,GAAgC;UACxBC,cAAc,GAAGC,WAAW,CAAXA,WAAW,CAAXA,GACnBC,YAAY,GADOD,qBACnBC,EADmBD,GAAvB,I;UAGME,cAAc,GAAGF,WAAW,CAAXA,QAAW,CAAXA,GACnBvE,MAAM,CADauE,qBACnBvE,EADmBuE,GAAvB,I;;UAKGD,cAAc,IAAII,iBAAiB,CAAA,WAAA,EAApC,cAAoC,CAAnCJ,IACAG,cAAc,IAAIC,iBAAiB,CAAA,WAAA,EAFtC,cAEsC,C,EACpC;AACAnJ,QAAAA,QAAQ,CAARA,cAAAA,CAAAA,MAAAA;;;AAGF6I,MAAAA,WAAW,GAAXA,cAAAA;AACAC,MAAAA,WAAW,GAAXA,cAAAA;;UAEI9I,QAAQ,CAARA,KAAAA,CAAJ,S,EAA8B;AAC5B2H,QAAAA,qBAAqB,CAArBA,cAAqB,CAArBA;;;;WAIG;AACL/G,MAAAA,OADK,EAAA,SAAA,OAAA,GACW;YACVZ,QAAQ,CAARA,KAAAA,CAAJ,M,EAA2B;AACzBoJ,UAAAA,cAAc;;;AAHb,K;;AA1CY,CAAvB;;AAsDA,SAAA,iBAAA,CAAA,KAAA,EAAA,KAAA,EAGW;MACLC,KAAK,IAAT,K,EAAoB;WAEhBA,KAAK,CAALA,GAAAA,KAAcC,KAAK,CAAnBD,GAAAA,IACAA,KAAK,CAALA,KAAAA,KAAgBC,KAAK,CADrBD,KAAAA,IAEAA,KAAK,CAALA,MAAAA,KAAiBC,KAAK,CAFtBD,MAAAA,IAGAA,KAAK,CAALA,IAAAA,KAAeC,KAAK,CAJtB,I;;;SAQF,I","sourcesContent":["import {Instance, CreateSingleton, Plugin} from '../types';\nimport tippy from '..';\nimport {defaultProps} from '../props';\nimport {errorWhen} from '../validation';\nimport {div} from '../utils';\n\n/**\n * Re-uses a single tippy element for many different tippy instances.\n * Replaces v4's `tippy.group()`.\n */\nconst createSingleton: CreateSingleton = (\n  tippyInstances,\n  optionalProps = {},\n  /** @deprecated use Props.plugins */\n  plugins = [],\n) => {\n  if (__DEV__) {\n    errorWhen(\n      !Array.isArray(tippyInstances),\n      [\n        'The first argument passed to createSingleton() must be an array of tippy',\n        'instances. The passed value was',\n        String(tippyInstances),\n      ].join(' '),\n    );\n  }\n\n  plugins = optionalProps.plugins || plugins;\n\n  tippyInstances.forEach(instance => {\n    instance.disable();\n  });\n\n  let userAria = {...defaultProps, ...optionalProps}.aria;\n  let currentAria: string | null | undefined;\n  let currentTarget: Element;\n  let shouldSkipUpdate = false;\n\n  const references = tippyInstances.map(instance => instance.reference);\n\n  const singleton: Plugin = {\n    fn(instance) {\n      function handleAriaDescribedByAttribute(isShow: boolean): void {\n        if (!currentAria) {\n          return;\n        }\n\n        const attr = `aria-${currentAria}`;\n\n        if (isShow && !instance.props.interactive) {\n          currentTarget.setAttribute(attr, instance.popperChildren.tooltip.id);\n        } else {\n          currentTarget.removeAttribute(attr);\n        }\n      }\n\n      return {\n        onAfterUpdate(_, {aria}): void {\n          // Ensure `aria` for the singleton instance stays `null`, while\n          // changing the `userAria` value\n          if (aria !== undefined && aria !== userAria) {\n            if (!shouldSkipUpdate) {\n              userAria = aria;\n            } else {\n              shouldSkipUpdate = true;\n              instance.setProps({aria: null});\n              shouldSkipUpdate = false;\n            }\n          }\n        },\n        onDestroy(): void {\n          tippyInstances.forEach(instance => {\n            instance.enable();\n          });\n        },\n        onMount(): void {\n          handleAriaDescribedByAttribute(true);\n        },\n        onUntrigger(): void {\n          handleAriaDescribedByAttribute(false);\n        },\n        onTrigger(_, event): void {\n          const target = event.currentTarget as Element;\n          const index = references.indexOf(target);\n\n          // bail-out\n          if (target === currentTarget) {\n            return;\n          }\n\n          currentTarget = target;\n          currentAria = userAria;\n\n          if (instance.state.isVisible) {\n            handleAriaDescribedByAttribute(true);\n          }\n\n          instance.popperInstance!.reference = target;\n\n          instance.setContent(tippyInstances[index].props.content);\n        },\n      };\n    },\n  };\n\n  return tippy(div(), {\n    ...optionalProps,\n    plugins: [singleton, ...plugins],\n    aria: null,\n    triggerTarget: references,\n  }) as Instance;\n};\n\nexport default createSingleton;\n","import {Instance, Targets, Plugin, Props} from '../types';\nimport tippy from '..';\nimport {errorWhen} from '../validation';\nimport {removeProperties, normalizeToArray, includes} from '../utils';\nimport {defaultProps} from '../props';\nimport {ListenerObject} from '../types-internal';\n\nconst BUBBLING_EVENTS_MAP = {\n  mouseover: 'mouseenter',\n  focusin: 'focus',\n  click: 'click',\n};\n\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */\nfunction delegate(\n  targets: Targets,\n  props: Partial<Props> & {target: string},\n  /** @deprecated use Props.plugins */\n  plugins: Plugin[] = [],\n): Instance | Instance[] {\n  if (__DEV__) {\n    errorWhen(\n      !(props && props.target),\n      [\n        'You must specity a `target` prop indicating a CSS selector string matching',\n        'the target elements that should receive a tippy.',\n      ].join(' '),\n    );\n  }\n\n  plugins = props.plugins || plugins;\n\n  let listeners: ListenerObject[] = [];\n  let childTippyInstances: Instance[] = [];\n\n  const {target} = props;\n\n  const nativeProps = removeProperties(props, ['target']);\n  const parentProps = {...nativeProps, plugins, trigger: 'manual'};\n  const childProps = {...nativeProps, plugins, showOnCreate: true};\n\n  const returnValue = tippy(targets, parentProps);\n  const normalizedReturnValue = normalizeToArray(returnValue);\n\n  function onTrigger(event: Event): void {\n    if (!event.target) {\n      return;\n    }\n\n    const targetNode = (event.target as Element).closest(target);\n\n    if (!targetNode) {\n      return;\n    }\n\n    // Get relevant trigger with fallbacks:\n    // 1. Check `data-tippy-trigger` attribute on target node\n    // 2. Fallback to `trigger` passed to `delegate()`\n    // 3. Fallback to `defaultProps.trigger`\n    const trigger =\n      targetNode.getAttribute('data-tippy-trigger') ||\n      props.trigger ||\n      defaultProps.trigger;\n\n    // Only create the instance if the bubbling event matches the trigger type\n    if (!includes(trigger, (BUBBLING_EVENTS_MAP as any)[event.type])) {\n      return;\n    }\n\n    const instance = tippy(targetNode, childProps);\n\n    if (instance) {\n      childTippyInstances = childTippyInstances.concat(instance);\n    }\n  }\n\n  function on(\n    node: Element,\n    eventType: string,\n    handler: EventListener,\n    options: object | boolean = false,\n  ): void {\n    node.addEventListener(eventType, handler, options);\n    listeners.push({node, eventType, handler, options});\n  }\n\n  function addEventListeners(instance: Instance): void {\n    const {reference} = instance;\n\n    on(reference, 'mouseover', onTrigger);\n    on(reference, 'focusin', onTrigger);\n    on(reference, 'click', onTrigger);\n  }\n\n  function removeEventListeners(): void {\n    listeners.forEach(({node, eventType, handler, options}: ListenerObject) => {\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function applyMutations(instance: Instance): void {\n    const originalDestroy = instance.destroy;\n    instance.destroy = (shouldDestroyChildInstances = true): void => {\n      if (shouldDestroyChildInstances) {\n        childTippyInstances.forEach(instance => {\n          instance.destroy();\n        });\n      }\n\n      childTippyInstances = [];\n\n      removeEventListeners();\n      originalDestroy();\n    };\n\n    addEventListeners(instance);\n  }\n\n  normalizedReturnValue.forEach(applyMutations);\n\n  return returnValue;\n}\n\nexport default delegate;\n","import {AnimateFill} from '../types';\nimport {BACKDROP_CLASS} from '../constants';\nimport {div, setVisibilityState} from '../utils';\nimport {warnWhen} from '../validation';\n\nconst animateFill: AnimateFill = {\n  name: 'animateFill',\n  defaultValue: false,\n  fn(instance) {\n    const {tooltip, content} = instance.popperChildren;\n\n    const backdrop = instance.props.animateFill\n      ? createBackdropElement()\n      : null;\n\n    function addBackdropToPopperChildren(): void {\n      instance.popperChildren.backdrop = backdrop;\n    }\n\n    return {\n      onCreate(): void {\n        if (backdrop) {\n          addBackdropToPopperChildren();\n\n          tooltip.insertBefore(backdrop, tooltip.firstElementChild!);\n          tooltip.setAttribute('data-animatefill', '');\n          tooltip.style.overflow = 'hidden';\n\n          instance.setProps({animation: 'shift-away', arrow: false});\n        }\n      },\n      onMount(): void {\n        if (backdrop) {\n          const {transitionDuration} = tooltip.style;\n          const duration = Number(transitionDuration.replace('ms', ''));\n\n          // The content should fade in after the backdrop has mostly filled the\n          // tooltip element. `clip-path` is the other alternative but is not\n          // well-supported and is buggy on some devices.\n          content.style.transitionDelay = `${Math.round(duration / 10)}ms`;\n\n          backdrop.style.transitionDuration = transitionDuration;\n          setVisibilityState([backdrop], 'visible');\n\n          // Warn if the stylesheets are not loaded\n          if (__DEV__) {\n            warnWhen(\n              getComputedStyle(backdrop).position !== 'absolute',\n              `The \\`tippy.js/dist/backdrop.css\\` stylesheet has not been\n              imported!\n              \n              The \\`animateFill\\` plugin requires this stylesheet to work.`,\n            );\n\n            warnWhen(\n              getComputedStyle(tooltip).transform === 'none',\n              `The \\`tippy.js/animations/shift-away.css\\` stylesheet has not\n              been imported!\n              \n              The \\`animateFill\\` plugin requires this stylesheet to work.`,\n            );\n          }\n        }\n      },\n      onShow(): void {\n        if (backdrop) {\n          backdrop.style.transitionDuration = '0ms';\n        }\n      },\n      onHide(): void {\n        if (backdrop) {\n          setVisibilityState([backdrop], 'hidden');\n        }\n      },\n      onAfterUpdate(): void {\n        // With this type of prop, it's highly unlikely it will be changed\n        // dynamically. We'll leave out the diff/update logic it to save bytes.\n\n        // `popperChildren` is assigned a new object onAfterUpdate\n        addBackdropToPopperChildren();\n      },\n    };\n  },\n};\n\nexport default animateFill;\n\nfunction createBackdropElement(): HTMLDivElement {\n  const backdrop = div();\n  backdrop.className = BACKDROP_CLASS;\n  setVisibilityState([backdrop], 'hidden');\n  return backdrop;\n}\n","import {\n  PopperElement,\n  Placement,\n  FollowCursor,\n  Props,\n  ReferenceElement,\n} from '../types';\nimport {\n  includes,\n  closestCallback,\n  useIfDefined,\n  isMouseEvent,\n  getOwnerDocument,\n} from '../utils';\nimport {getBasePlacement} from '../popper';\nimport {currentInput} from '../bindGlobalEventListeners';\nimport Popper from 'popper.js';\n\nconst followCursor: FollowCursor = {\n  name: 'followCursor',\n  defaultValue: false,\n  fn(instance) {\n    const {reference, popper} = instance;\n\n    let originalReference:\n      | ReferenceElement\n      | Popper.ReferenceObject\n      | null = null;\n\n    // Support iframe contexts\n    // Static check that assumes any of the `triggerTarget` or `reference`\n    // nodes will never change documents, even when they are updated\n    const doc = getOwnerDocument(instance.props.triggerTarget || reference);\n\n    // Internal state\n    let lastMouseMoveEvent: MouseEvent;\n    let mouseCoords: {clientX: number; clientY: number} | null = null;\n    let isInternallySettingControlledProp = false;\n\n    // These are controlled by this plugin, so we need to store the user's\n    // original prop value\n    const userProps = instance.props;\n\n    function setUserProps(props: Partial<Props>): void {\n      const keys = Object.keys(props) as Array<keyof Props>;\n      keys.forEach(prop => {\n        (userProps as any)[prop] = useIfDefined(props[prop], userProps[prop]);\n      });\n    }\n\n    function getIsManual(): boolean {\n      return instance.props.trigger.trim() === 'manual';\n    }\n\n    function getIsEnabled(): boolean {\n      // #597\n      const isValidMouseEvent = getIsManual()\n        ? true\n        : // Check if a keyboard \"click\"\n          mouseCoords !== null &&\n          !(mouseCoords.clientX === 0 && mouseCoords.clientY === 0);\n\n      return instance.props.followCursor && isValidMouseEvent;\n    }\n\n    function getIsInitialBehavior(): boolean {\n      return (\n        currentInput.isTouch ||\n        (instance.props.followCursor === 'initial' && instance.state.isVisible)\n      );\n    }\n\n    function resetReference(): void {\n      if (instance.popperInstance && originalReference) {\n        instance.popperInstance.reference = originalReference;\n      }\n    }\n\n    function handlePlacement(): void {\n      // Due to `getVirtualOffsets()`, we need to reverse the placement if it's\n      // shifted (start -> end, and vice-versa)\n\n      // Early bail-out\n      if (!getIsEnabled() && instance.props.placement === userProps.placement) {\n        return;\n      }\n\n      const {placement} = userProps;\n      const shift = placement.split('-')[1];\n\n      isInternallySettingControlledProp = true;\n\n      instance.setProps({\n        placement: (getIsEnabled() && shift\n          ? placement.replace(shift, shift === 'start' ? 'end' : 'start')\n          : placement) as Placement,\n      });\n\n      isInternallySettingControlledProp = false;\n    }\n\n    function handlePopperListeners(): void {\n      if (!instance.popperInstance) {\n        return;\n      }\n\n      // Popper's scroll listeners make sense for `true` only. TODO: work out\n      // how to only listen horizontal scroll for \"horizontal\" and vertical\n      // scroll for \"vertical\"\n      if (getIsEnabled() && getIsInitialBehavior()) {\n        instance.popperInstance.disableEventListeners();\n      }\n    }\n\n    function handleMouseMoveListener(): void {\n      if (getIsEnabled()) {\n        addListener();\n      } else {\n        resetReference();\n      }\n    }\n\n    function triggerLastMouseMove(): void {\n      if (getIsEnabled()) {\n        onMouseMove(lastMouseMoveEvent);\n      }\n    }\n\n    function addListener(): void {\n      doc.addEventListener('mousemove', onMouseMove);\n    }\n\n    function removeListener(): void {\n      doc.removeEventListener('mousemove', onMouseMove);\n    }\n\n    function onMouseMove(event: MouseEvent): void {\n      const {clientX, clientY} = (lastMouseMoveEvent = event);\n\n      if (!instance.popperInstance || !instance.state.currentPlacement) {\n        return;\n      }\n\n      // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n      const isCursorOverReference = closestCallback(\n        event.target as Element,\n        (el: Element) => el === reference,\n      );\n\n      const {followCursor} = instance.props;\n      const isHorizontal = followCursor === 'horizontal';\n      const isVertical = followCursor === 'vertical';\n      const isVerticalPlacement = includes(\n        ['top', 'bottom'],\n        getBasePlacement(instance.state.currentPlacement),\n      );\n\n      // The virtual reference needs some size to prevent itself from overflowing\n      const {size, x, y} = getVirtualOffsets(popper, isVerticalPlacement);\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        // Preserve custom position ReferenceObjects, which may not be the\n        // original targets reference passed as an argument\n        if (originalReference === null) {\n          originalReference = instance.popperInstance.reference;\n        }\n\n        instance.popperInstance.reference = {\n          referenceNode: reference,\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect(): DOMRect | ClientRect {\n            const rect = reference.getBoundingClientRect();\n            return {\n              width: isVerticalPlacement ? size : 0,\n              height: isVerticalPlacement ? 0 : size,\n              top: (isHorizontal ? rect.top : clientY) - y,\n              bottom: (isHorizontal ? rect.bottom : clientY) + y,\n              left: (isVertical ? rect.left : clientX) - x,\n              right: (isVertical ? rect.right : clientX) + x,\n            };\n          },\n        };\n\n        instance.popperInstance.update();\n      }\n\n      if (getIsInitialBehavior()) {\n        removeListener();\n      }\n    }\n\n    return {\n      onAfterUpdate(_, partialProps): void {\n        if (!isInternallySettingControlledProp) {\n          setUserProps(partialProps);\n\n          if (partialProps.placement) {\n            handlePlacement();\n          }\n        }\n\n        // A new placement causes the popperInstance to be recreated\n        if (partialProps.placement) {\n          handlePopperListeners();\n        }\n\n        // Wait for `.update()` to set `instance.state.currentPlacement` to\n        // the new placement\n        requestAnimationFrame(triggerLastMouseMove);\n      },\n      onMount(): void {\n        triggerLastMouseMove();\n        handlePopperListeners();\n      },\n      onShow(): void {\n        if (getIsManual()) {\n          // Since there's no trigger event to use, we have to use these as\n          // baseline coords\n          mouseCoords = {clientX: 0, clientY: 0};\n          // Ensure `lastMouseMoveEvent` doesn't access any other properties\n          // of a MouseEvent here\n          lastMouseMoveEvent = mouseCoords as MouseEvent;\n\n          handlePlacement();\n          handleMouseMoveListener();\n        }\n      },\n      onTrigger(_, event): void {\n        // Tapping on touch devices can trigger `mouseenter` then `focus`\n        if (mouseCoords) {\n          return;\n        }\n\n        if (isMouseEvent(event)) {\n          mouseCoords = {clientX: event.clientX, clientY: event.clientY};\n          lastMouseMoveEvent = event;\n        }\n\n        handlePlacement();\n        handleMouseMoveListener();\n      },\n      onUntrigger(): void {\n        // If untriggered before showing (`onHidden` will never be invoked)\n        if (!instance.state.isVisible) {\n          removeListener();\n          mouseCoords = null;\n        }\n      },\n      onHidden(): void {\n        removeListener();\n        resetReference();\n        mouseCoords = null;\n      },\n    };\n  },\n};\n\nexport default followCursor;\n\nexport function getVirtualOffsets(\n  popper: PopperElement,\n  isVerticalPlacement: boolean,\n): {\n  size: number;\n  x: number;\n  y: number;\n} {\n  const size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;\n\n  return {\n    size,\n    x: isVerticalPlacement ? size : 0,\n    y: isVerticalPlacement ? 0 : size,\n  };\n}\n","import {InlinePositioning, BasePlacement} from '../types';\nimport {arrayFrom} from '../utils';\nimport {getBasePlacement} from '../popper';\n\n// TODO: Work on a \"cursor\" value so it chooses a rect optimal to the cursor\n// position. This will require the `followCursor` plugin's fixes for overflow\n// due to using event.clientX/Y values. (normalizedPlacement, getVirtualOffsets)\nconst inlinePositioning: InlinePositioning = {\n  name: 'inlinePositioning',\n  defaultValue: false,\n  fn(instance) {\n    const {reference} = instance;\n\n    function getIsEnabled(): boolean {\n      return !!instance.props.inlinePositioning;\n    }\n\n    return {\n      onHidden(): void {\n        if (getIsEnabled()) {\n          instance.popperInstance!.reference = reference;\n        }\n      },\n      onShow(): void {\n        if (!getIsEnabled()) {\n          return;\n        }\n\n        instance.popperInstance!.reference = {\n          referenceNode: reference,\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect(): ClientRect | DOMRect {\n            return getInlineBoundingClientRect(\n              instance.state.currentPlacement &&\n                getBasePlacement(instance.state.currentPlacement),\n              reference.getBoundingClientRect(),\n              arrayFrom(reference.getClientRects()),\n            );\n          },\n        };\n      },\n    };\n  },\n};\n\nexport default inlinePositioning;\n\nexport function getInlineBoundingClientRect(\n  currentBasePlacement: BasePlacement | null,\n  boundingRect: ClientRect,\n  clientRects: ClientRect[],\n): ClientRect {\n  // Not an inline element, or placement is not yet known\n  if (clientRects.length < 2 || currentBasePlacement === null) {\n    return boundingRect;\n  }\n\n  switch (currentBasePlacement) {\n    case 'top':\n    case 'bottom': {\n      const firstRect = clientRects[0];\n      const lastRect = clientRects[clientRects.length - 1];\n      const isTop = currentBasePlacement === 'top';\n\n      const top = firstRect.top;\n      const bottom = lastRect.bottom;\n      const left = isTop ? firstRect.left : lastRect.left;\n      const right = isTop ? firstRect.right : lastRect.right;\n      const width = right - left;\n      const height = bottom - top;\n\n      return {top, bottom, left, right, width, height};\n    }\n    case 'left':\n    case 'right': {\n      const minLeft = Math.min(...clientRects.map(rects => rects.left));\n      const maxRight = Math.max(...clientRects.map(rects => rects.right));\n      const measureRects = clientRects.filter(rect =>\n        currentBasePlacement === 'left'\n          ? rect.left === minLeft\n          : rect.right === maxRight,\n      );\n\n      const top = measureRects[0].top;\n      const bottom = measureRects[measureRects.length - 1].bottom;\n      const left = minLeft;\n      const right = maxRight;\n      const width = right - left;\n      const height = bottom - top;\n\n      return {top, bottom, left, right, width, height};\n    }\n    default: {\n      return boundingRect;\n    }\n  }\n}\n","import {Sticky, ReferenceElement} from '../types';\nimport Popper from 'popper.js';\n\nconst sticky: Sticky = {\n  name: 'sticky',\n  defaultValue: false,\n  fn(instance) {\n    const {reference, popper} = instance;\n\n    function getReference(): ReferenceElement | Popper.ReferenceObject {\n      return instance.popperInstance\n        ? instance.popperInstance.reference\n        : reference;\n    }\n\n    function shouldCheck(value: 'reference' | 'popper'): boolean {\n      return instance.props.sticky === true || instance.props.sticky === value;\n    }\n\n    let prevRefRect: ClientRect | null = null;\n    let prevPopRect: ClientRect | null = null;\n\n    function updatePosition(): void {\n      const currentRefRect = shouldCheck('reference')\n        ? getReference().getBoundingClientRect()\n        : null;\n      const currentPopRect = shouldCheck('popper')\n        ? popper.getBoundingClientRect()\n        : null;\n\n      if (\n        (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect)) ||\n        (currentPopRect && areRectsDifferent(prevPopRect, currentPopRect))\n      ) {\n        instance.popperInstance!.update();\n      }\n\n      prevRefRect = currentRefRect;\n      prevPopRect = currentPopRect;\n\n      if (instance.state.isMounted) {\n        requestAnimationFrame(updatePosition);\n      }\n    }\n\n    return {\n      onMount(): void {\n        if (instance.props.sticky) {\n          updatePosition();\n        }\n      },\n    };\n  },\n};\n\nexport default sticky;\n\nfunction areRectsDifferent(\n  rectA: ClientRect | null,\n  rectB: ClientRect | null,\n): boolean {\n  if (rectA && rectB) {\n    return (\n      rectA.top !== rectB.top ||\n      rectA.right !== rectB.right ||\n      rectA.bottom !== rectB.bottom ||\n      rectA.left !== rectB.left\n    );\n  }\n\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}